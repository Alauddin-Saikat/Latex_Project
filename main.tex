%% bare_jrnl.tex
%% V1.4b
%% 2015/08/26
%% by Michael Shell
%% see http://www.michaelshell.org/
%% for current contact information.
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.8b or later) with an IEEE
%% journal paper.
%%
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/pkg/ieeetran
%% and
%% http://www.ieee.org/

%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE! 
%% User assumes all risk.
%% In no event shall the IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%*************************************************************************


% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX platform ***
% *** with production work. The IEEE's font choices and paper sizes can   ***
% *** trigger bugs that do not appear when using other class files.       ***                          ***
% The testflow support page is at:
% http://www.michaelshell.org/tex/testflow/



\documentclass[journal, twoside]{IEEEtran}
%
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[journal]{../sty/IEEEtran}





% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)


% *** MISC UTILITY PACKAGES ***
%
%\usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/pkg/ifpdf
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.






% *** CITATION PACKAGES ***
%
%\usepackage{cite}
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of the IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off
% such as if a citation ever needs to be enclosed in parenthesis.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 5.0 (2009-03-20) and later if using hyperref.sty.
% The latest version can be obtained at:
% http://www.ctan.org/pkg/cite
% The documentation is contained in the cite.sty file itself.






% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
  % \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi
% graphicx was written by David Carlisle and Sebastian Rahtz. It is
% required if you want graphics, photos, etc. graphicx.sty is already
% installed on most LaTeX systems. The latest version and documentation
% can be obtained at: 
% http://www.ctan.org/pkg/graphicx
% Another good source of documentation is "Using Imported Graphics in
% LaTeX2e" by Keith Reckdahl which can be found at:
% http://www.ctan.org/pkg/epslatex
%
% latex, and pdflatex in dvi mode, support graphics in encapsulated
% postscript (.eps) format. pdflatex in pdf mode supports graphics
% in .pdf, .jpeg, .png and .mps (metapost) formats. Users should ensure
% that all non-photo figures use a vector format (.eps, .pdf, .mps) and
% not a bitmapped formats (.jpeg, .png). The IEEE frowns on bitmapped formats
% which can result in "jaggedy"/blurry rendering of lines and letters as
% well as large increases in file sizes.
%
% You can find documentation about the pdfTeX application at:
% http://www.tug.org/applications/pdftex





% *** MATH PACKAGES ***
%
%\usepackage{amsmath}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics.
%
% Note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/pkg/amsmath





% *** SPECIALIZED LIST PACKAGES ***
%
%\usepackage{algorithmic}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as the IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/pkg/algorithms
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/pkg/algorithmicx




% *** ALIGNMENT PACKAGES ***
%
%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/pkg/array


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.




% *** SUBFIGURE PACKAGES ***
%\ifCLASSOPTIONcompsoc
%  \usepackage[caption=false,font=normalsize,labelfont=sf,textfont=sf]{subfig}
%\else
%  \usepackage[caption=false,font=footnotesize]{subfig}
%\fi
% subfig.sty, written by Steven Douglas Cochran, is the modern replacement
% for subfigure.sty, the latter of which is no longer maintained and is
% incompatible with some LaTeX packages including fixltx2e. However,
% subfig.sty requires and automatically loads Axel Sommerfeldt's caption.sty
% which will override IEEEtran.cls' handling of captions and this will result
% in non-IEEE style figure/table captions. To prevent this problem, be sure
% and invoke subfig.sty's "caption=false" package option (available since
% subfig.sty version 1.3, 2005/06/28) as this is will preserve IEEEtran.cls
% handling of captions.
% Note that the Computer Society format requires a larger sans serif font
% than the serif footnote size font used in traditional IEEE formatting
% and thus the need to invoke different subfig.sty package options depending
% on whether compsoc mode has been enabled.
%
% The latest version and documentation of subfig.sty can be obtained at:
% http://www.ctan.org/pkg/subfig




% *** FLOAT PACKAGES ***
%
%\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure.
% Be aware that LaTeX2e kernels dated 2015 and later have fixltx2e.sty's
% corrections already built into the system in which case a warning will
% be issued if an attempt is made to load fixltx2e.sty as it is no longer
% needed.
% The latest version and documentation can be found at:
% http://www.ctan.org/pkg/fixltx2e


%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/pkg/stfloats
% Do not use the stfloats baselinefloat ability as the IEEE does not allow
% \baselineskip to stretch. Authors submitting work to the IEEE should note
% that the IEEE rarely uses double column equations and that authors should try
% to avoid such use. Do not be tempted to use the cuted.sty or midfloat.sty
% packages (also by Sigitas Tolusis) as the IEEE does not format its papers in
% such ways.
% Do not attempt to use stfloats with fixltx2e as they are incompatible.
% Instead, use Morten Hogholm'a dblfloatfix which combines the features
% of both fixltx2e and stfloats:
%
% \usepackage{dblfloatfix}
% The latest version can be found at:
% http://www.ctan.org/pkg/dblfloatfix




%\ifCLASSOPTIONcaptionsoff
%  \usepackage[nomarkers]{endfloat}
% \let\MYoriglatexcaption\caption
% \renewcommand{\caption}[2][\relax]{\MYoriglatexcaption[#2]{#2}}
%\fi
% endfloat.sty was written by James Darrell McCauley, Jeff Goldberg and 
% Axel Sommerfeldt. This package may be useful when used in conjunction with 
% IEEEtran.cls'  captionsoff option. Some IEEE journals/societies require that
% submissions have lists of figures/tables at the end of the paper and that
% figures/tables without any captions are placed on a page by themselves at
% the end of the document. If needed, the draftcls IEEEtran class option or
% \CLASSINPUTbaselinestretch interface can be used to increase the line
% spacing as well. Be sure and use the nomarkers option of endfloat to
% prevent endfloat from "marking" where the figures would have been placed
% in the text. The two hack lines of code above are a slight modification of
% that suggested by in the endfloat docs (section 8.4.1) to ensure that
% the full captions always appear in the list of figures/tables - even if
% the user used the short optional argument of \caption[]{}.
% IEEE papers do not typically make use of \caption[]'s optional argument,
% so this should not be an issue. A similar trick can be used to disable
% captions of packages such as subfig.sty that lack options to turn off
% the subcaptions:
% For subfig.sty:
% \let\MYorigsubfloat\subfloat
% \renewcommand{\subfloat}[2][\relax]{\MYorigsubfloat[]{#2}}
% However, the above trick will not work if both optional arguments of
% the \subfloat command are used. Furthermore, there needs to be a
% description of each subfigure *somewhere* and endfloat does not add
% subfigure captions to its list of figures. Thus, the best approach is to
% avoid the use of subfigure captions (many IEEE journals avoid them anyway)
% and instead reference/explain all the subfigures within the main caption.
% The latest version of endfloat.sty and its documentation can obtained at:
% http://www.ctan.org/pkg/endfloat
%
% The IEEEtran \ifCLASSOPTIONcaptionsoff conditional can also be used
% later in the document, say, to conditionally put the References on a 
% page by themselves.




% *** PDF, URL AND HYPERLINK PACKAGES ***
%
%\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version and documentation can be obtained at:
% http://www.ctan.org/pkg/url
% Basically, \url{my_url_here}.




% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )


% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}
\usepackage{amsmath}
\usepackage[pdftex]{graphicx}
\usepackage{caption}
\usepackage{textcomp}
\usepackage[labelfont=up,labelsep=newline, font=scriptsize, skip=1ex]{caption}


%Koushik's pakages%
\usepackage{amsthm}
\usepackage[bb=boondox]{mathalfa}
\usepackage[normalem]{ulem}
\useunder{\uline}{\ul}{}

%\graphicspath{ {./Figures/} }
\begin{document}
%
% paper title
% Titles are generally capitalized except for words such as a, an, and, as,
% at, but, by, for, in, nor, of, on, or, the, to and up, which are usually
% not capitalized unless they are the first or last word of the title.
% Linebreaks \\ can be used within to get better formatting as desired.
% Do not put math or special symbols in the title.
\title{The Automatic Generation of Load Test Suites and
the Assessment of the Resulting Software}
%
%
% author names and IEEE memberships
% note positions of commas and nonbreaking spaces ( ~ ) LaTeX will not break
% a structure at a ~ so this keeps an author's name from being broken across
% two lines.
% use \thanks{} to gain access to the first footnote area
% a separate \thanks must be used for each paragraph as LaTeX2e's \thanks
% was not built to handle multiple paragraphs
%

\author{Alberto Avritzer and Elaine J. Weyuker,% <-this % stops a space
\thanks{Manuscript received June 1994; revised December 1994.
A. Avritzer is with AT&T Bell Laboratories, Red Hill, NJ 07748.
E.J. Weyuker is with AT&T Bell Laboratories, Murray Hill, NJ 07974
IEEECS Log Number S95032.}% <-this % stops a space
}


% note the % following the last \IEEEmembership and also \thanks - 
% these prevent an unwanted space from occurring between the last author name
% and the end of the author line. i.e., if you had this:
% 
% \author{....lastname \thanks{...} \thanks{...} }
%                     ^------------^------------^----Do not want these spaces!
%
% a space would be appended to the last name and could cause every name on that
% line to be shifted left slightly. This is one of those "LaTeX things". For
% instance, "\textbf{A} \textbf{B}" will typeset as "A B" not "AB". To get
% "AB" then you have to do: "\textbf{A}\textbf{B}"
% \thanks is no different in this regard, so shield the last } of each \thanks
% that ends a line with a % and do not let a space in before the next \thanks.
% Spaces after \IEEEmembership other than the last one are OK (and needed) as
% you are supposed to have spaces between the names. For what it is worth,
% this is a minor point as most people would not even notice if the said evil
% space somehow managed to creep in.



% The paper headers
\markboth{IEEE TRANSACTIONS ON AUDIO,~SPEECH,~AND~LANGUAGE~PROCESSING,~VOL.~16, NO.~9,~SEPTEMBER~1995}
{IEEE TRANSACTIONS ON AUDIO,~SPEECH,~AND~LANGUAGE~PROCESSING,~VOL.~16, NO.~2,~FEBRUARY~2008}
\markright{YANG \MakeLowercase{\textit{et al.}}: REGRESSION APPROACH TO MUSIC EMOTION RECOGNITION}
% The only time the second header will appear is for the odd numbered pages
% after the title page when using the twoside option.
% 
% *** Note that you probably will NOT want to include the author's ***
% *** name in the headers of peer review papers.                   ***
% You can use \ifCLASSOPTIONpeerreview for conditional compilation here if
% you desire.




% If you want to put a publisher's ID mark on the page you can do it like
% this:
\IEEEpubid{0098-5589/95\$04.00 \textcopyright\ 1995 IEEE}
% Remember, if you use this you must call \IEEEpubidadjcol in the second
% column for its text to clear the IEEEpubid mark.



% use for special paper notices
%\IEEEspecialpapernotice{(Invited Paper)}


\IEEEaftertitletext{\vspace{-2\baselineskip}}

% make the title area
\maketitle

% As a general rule, do not put math, special symbols or citations
% in the abstract or keywords.
\begin{abstract}
Three automatic test case generation algorithms intended to test the resource allocation mechanisms of telecommunications software systems are introduced. Although these techniques were specifically designed for testing telecommunications
software, they can be used to generate test cases for any software
system that is modelable by a Markov chain provided operational
profile data can either be collected or estimated. These algorithms
have been used successfully to perform load testing for several
real industrial software systems. Experience generating test suites
for five such systems is presented. Early experience with the algorithms indicate that they are highly effective at detecting subtle
faults that would have been likely to be missed if load testing had
been done in the more traditional way, using hand-crafted test
cases. A domain-based reliability measure is applied to systems
after the load testing algorithms have been used to generate test
data. Data are presented for the same five industrial telecommunications systems in order to track the reliability as a function of
the degree of system degradation experienced. \\

\textit{Index Terms\(-\)}Automatic test case generation, software testing,
reliability assessment, Markov chains.
\end{abstract}

\section{Introduction}
\IEEEPARstart{A}{MAJOR} challenge for organizations that develop software for industrial purposes is to determine ways to comprehensively test the resource allocation mechanisms associated
with the software in a cost effective manner. Although there is
a great deal of literature describing testing strategies that address the functionality of the software under test, there is very
little literature describing approaches to this related, but distinct, problem.

In this paper, we therefore address several issues related to
the testing of resource allocation in systems \textit{after} the system
functionality has been thoroughly tested. The algorithms we
propose are \textit{black-box} testing techniques since they do not rely
at all on details of the implementation. They are examples of
what are typically called \textit{load testing} strategies, since they
assess how the system performs under a, given ‘‘load.’’ The
strategies we introduce are based on an \textit{operational profile}
which describes the expected workload of the system once it is
operational in the field [7]. The operational profile for a telecommunications system typically includes the following types
of information: the number of different types of calls, the average service demands and probability distribution for each type
of call, and the average external arrival rate and probability
distribution for each call type. If the same types of calls can be routed through different locations (so-called \textit{service centers}),
then the routing probabilities between service centers for each
call type would also typically be included. We have generally
found the needed operational profile information to be readily
available for the projects with which we have worked.

In the research literature for local area networks (LANs), a
distinction is frequently made between \textit{hard failures} and soft
failures. A hard failure is said to occur when there is a problem that leads to no traffic through the network. This might be
due to such events as the severance of a network cable leading
to a physical discontinuity in the network, a power failure, or a
failure of one or more major network components such as a
router. The analogue of a hard failure for a software system is
a system crash. In such a c?se, the system is totally unavailable
until some intervention has been taken.

\textit{A soft failure}, in contrast, is said to occur in a network when
the network’s performance has degraded. These performance
degradations might be either transient or permanent. For example, intermittent electrical problems might lead to transient
failures which disappear dnce the cause of the problem has
been removed. For a software system, this type of intermittent
soft failure might happen when a burst of activity occurs, requiring more resources than the system has available. In the
case of telecommunications systems, if the total number of
active calls plus the number of incoming calls exceeds the
system’s capacity, some calls will be lost. Once the load decreases, the system resumes normal operation. In a typical
telecommunications system, it is extremely important that this
type of failure does not occur. For this reason, telecommunications systems are typically designed with a very substantial
amount of excess capacity so that the probability of call loss or
blockage in a properly functioning system is very low. This
means that this type of intermittent soft failure is very unusual
in the systems we will be considering because the systems
have been designed explicitly to prevent this type of failure.
 
 If a soft failure is permanent, then once the degradation has
begun, the network remains in a degraded state until appropriate intervention has been taken to restore acceptable performance. The analogue of a permanent soft failure for software is
a problem that leads to a degradation of the software that does
not abate when the load decreases.

\IEEEpubidadjcol
When doing load testing of telecommunications systems, it
is extremely unusual to see a hard failure, and as mentioned
above, systems are typically designed to prevent soft transient
failures. In fact, at this stage it is unusual to see \textit{any} type of
failure, but among the few failures that we see, the typical failure is a permanent soft failure. That is, a failure typically consists of a situation in which the service provided to some users
is not entirely acceptable because the system has degraded so
that full capacity is not available. In this case, calls (or users)
are lost to the system, even though there are ample resources
available. In such a situation, once the system enters this type
of faulty state, the system typically continues to degrade, losing more and more users, or in our environment, preventing
the completion of increasing numbers of calls. We refer to this
situation as a \textit{smoothly degrading} system. It is this type of
system and failure that we consider in this paper, and the primary goal of the testing approach that we present here is to
identify and fix these types of faults, thereby preventing the
associated soft failures.
\IEEEpubidadjcol

In [1], a new automatic test case generation strategy for performing load testing for systems that can be modeled by
Markov chains was proposed. In the current paper, we introduce two additional variants of these algorithms. These new
strategies increase the class of detectable faults by examining
not only the amount of resources allocated, but also the order
of that allocation. For each of the three algorithms, a domain based reliability measure is defined.

The algorithms were used to generate test suites for five industrial telecommunications projects, and our experience is
reported. Preliminary results are extremely encouraging, and
are described in Sections 1II.B and 1V.B. In Section V we also
consider interesting uses of the reliability computation. 
\section{The Model}
In this section we include a very brief introduction to
Markov processes as necessary to understand our test case
generation approach. A much more thorough description of
this background material is available in [5]. We also provide a
brief introduction to the terminology needed to understand the
application domain in which we have applied our algorithms:
telecommunications systems.

Let \(X\) be a set of random variables.\(X\) = \{\(x_i\)\}  is said to form a \textit{Markov chain}  provided that the probability that the next state
is \(x_{m+1}\) is independent of everything other than the current
state, \(x_m\). Thus, the only way that the past history of the process
can affect the future is through the current state. This is sometimes known as the \textit{memory less property}.

In the telecommunications application domain, a typical
state might represent an n-tuple of call types, with the \textit{i}th element of the n-tuple, \(m_i\),  representing the numbers of active
calls of type \(i\). If the system is in state (\(m_l, m_2, ..., m_i, ..., m_n,\)),and a new call of type \(i\), is placed, the system enters state (\(m_1, m_2, ...,m_i+1, ..., m_n\)). There are typically two types of transitions in these systems: call arrivals and call completions. Associated with each transition is a value representing the call
arrival or completion rate.

The \textit{holding time} e for a call includes all the time during
which the call is active, including all the time that the caller is
using the system. The \textit{call arrival rate }is simply the average rate at which calls of a given type enter the system. Similarly,the call \textit{completion or departure rate} is the rate at which calls leave the system. This is equal to the inverse of the average
call holding time for that call type, times the number of calls of the given type in the state. Thus, if the average call holding time is two minutes for a call of a given type, then the departure rate for that call type from a state containing \(N_i\) calls of
that type is \(\frac{N_i}{2}\). \textit{Call blocking} is said to occur if a call cannot be completed because all circuits are already allocated to other calls.

The only continuous-time distribution that exhibits the
memoryless property is the exponential distribution [5]. We
therefore require that the average time for a transition out of a state be exponentially distributed: We assume that each call type forms an independent Poisson process with a specified arrival rate, and that call holding times are exponentially distributed. It is generally agreed that most telecommunications systems can be accurately modeled in this way.

One special case of a Markov chain is known as a \textit{birth-death process}, which requires that the only state transitions
that can occur are between so-called \textit{neighboring states}. That
is, the states can be numbered in such a way that if \(x_n = i\), then \(x_{n+l}\) must be \(i, i - 1,\) or \(i + 1.\) Viewed from the perspective of a single call type, the systems we consider can be modeled in this way, and we approximate the behavior of actual states of our system which represent vectors of call types by considering the product of these factor solutions.

The general steady-state solution for birth-death queuing
systems is derived in [5]. 

The solution for this type of system for a single call type is given by: 
\begin{equation}
    p_k = \frac{\lambda_0\lambda_1...\lambda_{k-1}}{\mu_1\mu_2...\mu_k}
\end{equation}
where \(p_i\) denotes the probability that there are \(i\) calls of the specified type, \(\lambda_i\) denotes the call arrival rate when there are \(i\) active calls of the specified type, and \(\mu_i\) denotes the call
completion rate when there are \(i\) active calls of the specified type.

Equation (1) can be rewritten as: 
\begin{equation}
    p_k=\frac{\lambda_{k-1} }{\mu_k} p_{k-1}
\end{equation}
that is, the probability of having \(k\)  calls of a given type at a given time is equal to the probability of having \(k - 1\) calls of that type, times the ratio of the call arrival rate when there are \(k - 1\) calls in the system and the call departure rate when there are \(k\) active calls of the given type.This ratio represents the
expected number of active calls of the given type. It follows
immediately from (2) that if  $ \frac{\lambda_{i-1}}{\mu_i}<1 $   , $  p_i < p_{i-1} $ . The condition for the existence of equilibrium probabilities is that
there exists a $k$ , such that for all   $ i \geq k $ , $ \frac{\lambda_{i-1}}{\mu_i}<1 $ . This observation is important as it will frequently allow us to truncate the
number of states considered by the algorithms presented in the next section.

In Section 111 we describe a family of three test generation
algorithms. In the first algorithm, all faults under consideration
are entirely associated with a state. The second algorithm also
considers faults which might be associated with individual
transitions between states, while the third algorithm considers
subpaths of varying lengths from a given state, back to itself.
Note that when we assume that the system is being modeled by
a Markov chain, we do so \textit{only} to derive the steady-state probability distribution for the states, and not for the determination
of potential faults. Of course, it may be the case that faults
occur that are dependent on the explicit path exercised, rather
than being entirely state dependent, and it is for that reason
that the second and third algorithms are introduced.

The proposed approach is to generate only those software
states, and hence associated test cases, that have probabilities
greater than a heuristically computed $\varepsilon$ , and thus represent
software states that are the most likely to be reached in the
field. Letting $K$ denote the number of states with probability
greater than $\varepsilon$ , it follows that $\varepsilon$  and $K$ are related by the           
steady-state probability distribution, and by the total number of
calls, $M$, generated by the $K$ test cases. We typically start with
a small value for $\varepsilon$  and tune it until the number of test cases is
approximately equal to a number indicated by the testers as
feasible to perform. This tuning of  $\varepsilon$  is done using a binary search.

The structure of the problem leads to the following recursion: generate the current state and all states derived from it by
adding one more outstanding call of type $x$, until the test case
probability is less than $ \varepsilon $.On return, increment to the next type
of call, and recursively repeat the procedure.
To simplify the description of the algorithms, we assume
that call types are sorted by $\frac{\lambda_i}{\mu_i}$. That is, the call type with the
greatest expected number of active calls will be call type 1, the
second highest will be type 2, and so on. 

\section{THE MARKOV STATE TESTING APPROACH}
Deterministic Markov state testing is a test case generation
and execution approach designed for performing load testing
for telecommunications software according to an operational
profile. Note that although we generally speak of applying our
test case generation algorithms to test the software of telecommunications systems, our procedure is suitable for any
software systems that meet the above-outlined assumptions,
with the state appropriately defined. In Section III.B, we will
present our experience applying these algorithms to perform
load testing for five industrial software telecommunications
systems. Of these five projects, only Project 1 has call types as
the primary operations. This should give the reader a feel for
the range of applications for which our algorithms can and
have been used. Throughout the paper, however, we will continue to speak about telephone calls as the primary operations,
since this is a concrete application that is easy for most readers
to conceptualize.

A central problem associated with the type of software we
consider here is that even for systems with a relatively small number of call types, and modest upper bound on the number
of calls that the system can handle, there will typically be a
huge number of distinct states. Since each state of the Markov
chain corresponds to one or more test cases for load testing,
this translates to a vast amount of required testing if total coverage of the state space is required. For a system that can handle k distinct types of calls, and a maximum of n calls, the
system would contain   
$\begin{pmatrix}
n+k \\
n
\end{pmatrix}$  states. Thus, a system that can
handle a maximum of 24 calls of five distinct types would
have a total of 1 18,755 Markov states. To test every state once
would require a total of 5,938 hours of testing, assuming three
minutes holding time for each call. If the maximum number of
calls were increased to 500, there would be a total of
268,3 18,178,226 Markov states requiring over 13,000,000,000
hours of testing assuming three minutes holding time. Since
this clearly requires a prohibitive amount of resources, some
way of intelligently selecting a relatively small subset of these
potential test cases must be developed. 

Our algorithms therefore involve a recognition that faults
associated with those states that correspond to the most likely
states to be executed, translate into failures that are most likely
to be encountered in the field, and hence situations that are
most likely to be problematic. Thus, in order to minimize observed field failures, our first test case generation approach
stresses the testing of those states of the Markov chain that
have the greatest likelihood of being encountered. Note that a
Markov chain can be represented by a graph, and hence when
we speak of edges, paths, or cycles, we are really referring to
the state transitions and sequences of transitions.

By limiting our first test case generation algorithm to the
selection of at most one test case per state, there is a tacit assumption being made that the only faults of interest are those
that are directly associated with a particular state, and not the
edge or path traversed to arrive at the state. Looking at this
from a different perspective, this can be viewed as an assumption that all paths to a state are equally likely to be faulty. Although we would certainly not argue that this is a reasonable
assumption for earlier stages of (functionality) testing, experience has shown that this is frequently reasonable for performing load testing. Typical faults that we expect to be detected by
this approach involve improper allocation of resources such as
buffers, demons, or memory, leading to a loss of calls, or a
store and forward deadlock in a client/server environment.

If in addition to testing state definitions, it is determined
that the edge taken to the state should also be tested at this
stage, we provide a second algorithm that generates in order,
all state transitions such that the product of the state probability and the call arrival rate is greater than $\varepsilon$. . A typical type of
fault that might be detected by this algorithm is a degradation
of the number of calls that can be accepted by the system. This
is a common type of problem for telecommunications systems.
For example, data from eleven test sessions for an actual industrial project are shown in Table I. The total number of client and subscriber calls made during the run, and the call
completion rate achieved are shown. These call completion
rates clearly identify a major degradation in the system avail- \vspace{5cm} 

ability, which is visible to the user as calls unable to complete.
For this project, originally described in [l], the system was
rebooted after test sessions three and nine in order to restore
the system to full capacity as a temporary fix. Once the problem was identified using our approach to the generation of
load test suites, however, a more satisfactory and permanent
correction was made. 

\begin{table}[ht]
    \centering
    \caption{ADJUNCT SYSTEM TEST RESULTS}
    \label{tab:my_label}
    \begin{tabular}{|l|l|l|l|l|}
\hline
\begin{tabular}[c]{@{}l@{}}Session\\     \#\end{tabular} & \multicolumn{2}{l|}{Client Calls}                                                                                               & \multicolumn{2}{l|}{Subscriber Calls}                                                                                            \\ \hline
                                                         & \begin{tabular}[c]{@{}l@{}}Calls\\ Initiated\end{tabular} & \begin{tabular}[c]{@{}l@{}}Call Comp-\\ letion \\ Rate\end{tabular} & \begin{tabular}[c]{@{}l@{}}Calls \\ Initiated\end{tabular} & \begin{tabular}[c]{@{}l@{}}Call Comp-\\ letion \\ Rate\end{tabular} \\ \hline
1                                                        & 1516                                                      & 97                                                                  & 77                                                         & 99                                                                  \\ \hline
2                                                        & 1679                                                      & 48                                                                  & 179                                                        & 47                                                                  \\ \hline
3                                                        & 1578                                                      & 23                                                                  & 261                                                        & 24                                                                  \\ \hline
4                                                        & 1547                                                      & 100                                                                 & 279                                                        & 96                                                                  \\ \hline
5                                                        & 1531                                                      & 99                                                                  & 358                                                        & 92                                                                  \\ \hline
6                                                        & 1360                                                      & 98                                                                  & 402                                                        & 90                                                                  \\ \hline
7                                                        & 5869                                                      & 40                                                                  & 1328                                                       & 33                                                                  \\ \hline
8                                                        & 1280                                                      & 20                                                                  & 478                                                        & 26                                                                  \\ \hline
9                                                        & 4715                                                      & 22                                                                  & 752                                                        & 26                                                                  \\ \hline
10                                                       & 2668                                                      & 100                                                                 & 511                                                        & 100                                                                 \\ \hline
11                                                       & 2775                                                      & 100                                                                 & 566                                                        & 98                                                                  \\ \hline
\end{tabular}
    
\end{table}
Our third algorithm extends the second by considering subpaths rather than individual edges. A typical type of fault that
might be detected by this algorithm is a memory leak that prevents state reachability. The three test case generation algorithms are presented below. 
\subsection{The Algorithms}
\begin{enumerate}
    \item \textit{Deterministic State Testing (DST) }
    \begin{enumerate}
        \item \textit{Strategy.}Generate all states that have steady-state probability greater than $\varepsilon$.
        \item \textit{Algorithm DST(S).} Generate a list of test cases starting from the software state S.
        \begin{enumerate}
            \item Set the index, x, for call type to 1.
            \item  Set N to 1 plus the number of outstanding calls of type x in state S.
            \item  If by adding one more call of type $x$,  a previously unreached state is reached and the steady-state probability of the state so generated is greater than $\varepsilon$ or $\frac{\lambda_x}{\mu_x}\geq1$  then:
            \begin{itemize}
                \item Generate a test case for the software state reached from $S$ by adding one more outstanding call of type $x$. Call it state $S^'$;
                \item Generate a list of test cases by recursively executing DST($S^'$); 
                \item If $x$ is greater than the number of call types return; 
                \item Otherwise set the index of call types to $x + 1$, and go to step 2.
            \end{itemize}
        \end{enumerate}
    \end{enumerate}
    Note that we discard states with probabilities less than $\varepsilon$ if
    $\frac{\lambda_x}{\mu_x}<1$  because all states generated from these are guaranteed to have probabilities less than $\varepsilon$. If $\frac{\lambda_x}{\mu_x}\geq1$ , it follows from our observations in Section I1 that the fact that the probability associated with a state is less than  $\varepsilon$ does not necessarily imply that successor states will have a probability less than $\varepsilon$, and hence in this case, these states are not discarded.
    
    The algorithm is initialized by setting S = ($0, 0, . . . , 0$), and executing DST(S). 
    \item Deterministic State Testing With State Transition Checking (TDST)
    \begin{enumerate}
        \item \textit{Strategy.} For each state S generated by the DST strategy, verify that all transitions out of S due to a call arrival of type $x$ reach the correct state, provided $p(S) * \lambda_x >\varepsilon$. 
        \item \textit{Algorithm}. For each state S generated by DST do: 
        \begin{enumerate}
            \item  Generate state S from the idle state. 
            \item Certify that state S was properly reached.
            \item  For each call type $i$ for which $p(S) * \lambda_x >\varepsilon$ do:
            \begin{itemize}
                \item  Generate state $S^'$ by the initiation of one more call of type $i$. 
                \item Certify that state $S^'$ was properly reached.
                \item Regenerate state $S$ by the removal of one call of type $i$. 
                \item Certify that the system has returned to state $S$.
            \end{itemize}
        \end{enumerate}
    \end{enumerate}
    \item Deterministic State Testing with Length N Cycles (CDST)
    \begin{enumerate}
        \item \textit{Strategy. }Let the flow of a cycle be the minimum flow along the cycle edges, where the flow of an edge is the product of the probability associated with the origin of the edge and the rate associated with the edge. Generate all cycles of length $N$ with cycle flow greater than $\varepsilon$ .
        \item \textit{Algorithm.} For each state S generated by DST do: 
        \begin{enumerate}
            \item Generate state $S$ from the idle state.
            \item Certify that state $S$ was properly reached
            \item  For each simple cycle of length $N$ originating at $S$ with cycle flow greater than $\varepsilon$ do: 
            \begin{itemize}
                \item  Generate the N states in the cycle.
                \item  Certify that state $S$ was properly regenerated. 
            \end{itemize}
        \end{enumerate}
    \end{enumerate}
\end{enumerate}
Several recent papers [2], [3], [4], [lo] have discussed
partition testing strategies, or, as they are more properly
called, sub domain testing strategies. These strategies are characterized by the fact that they first divide the input domain into
subsets known as sub domains, and then select one or more
elements from each such sub domain. The basis for the division
may include such things as the implementation, the specification, or a set of expected faults. The resulting test case selection strategy is then said to be a program-based, specification based, or fault-based strategy, respectively. Program-based
testing is also known as white-box testing, and specification based testing is also known as black-box or functional testing.
Of course, strategies could also be defined that combine two or
more of these information sources.


The three strategies we introduced above are all black-box, \vspace{3cm}
fault-based, sub domain testing strategies. Since each sub domain describes the actual system load, the sub domains are
necessarily disjoint, and therefore, form a true partition in the
mathematical sense.

There is an underlying tacit assumption that at this stage of
testing, the individual telephone numbers selected are not of
importance, only the number and types of calls placed. It
therefore follows that the faults that we consider are all directly associated with individual states, transitions, or cycles,
and therefore the selection of more than one test case from a
given sub domain is redundant. Viewed another way, each of
the sub domains has the property that, relative to the class of
faults being considered, either every element of the sub domain
is processed correctly or every element of the sub domain is
processed incorrectly. Sub domains with this property were
said to be revealing in [11] and homogeneous in [4]. 

\subsection{Empirical Results}
In this section we present our experience working with five
industrial software telecommunications projects, ranging in
size from 50,000 to more than one million lines of code. A
brief description of each system follows, and trafic data are
shown for these projects in Tables I1 to VI. Arrival processes
are assumed Poisson, with holding times assumed to be exponentially distributed. 
\begin{enumerate}
    \item Project 1 is an adjunct service used to reroute calls from clients and subscribers. We identified five activities that represent the bulk of the software processing: client call completes to subscriber, call cannot reach subscriber, call to update subscriber profile, call to check status, and call to access mail. 
    \item Project 2 is a provisioning system used to monitor 800 number call traffic. We identified three activities that represent the bulk of processing: provisioning of new users, maintenance, and file transfer. 
    \item  Project 3 is a routing automator. We identified five activities that represent the bulk of processing: database query, file transfer, trigger for access, trigger for node, and interface management. 
    \item  Project 4 is a transaction processing system. We identified four activities that represent the bulk of the processing: open, close, update, and list. 
    \item Project 5 is a network interface software. We identified three activities that represent the bulk of processing: on demand request, control request, and echo request. 
\end{enumerate}
Each of the systems was designed to operate at low to medium utilization rates so that the probability of call blockage is
very low. For this reason, each of the systems had built into it
a substantial amount of excess capacity to insure that the probability of blockage in a properly functioning system would be
very low. Therefore, except in unusual situations, call loss is
due to improper system function. We will examine the implications of this design characteristic in Section 1V.B when we
investigate the reliability of systems tested using our test generation algorithms. 

The automated tools necessary to apply the three algorithms
have been built and used to generate test suites that were used
to do load testing for two of the five projects described above.
Test suites for the other three projects have also been generated using the tool, but have not yet been run by the projects.
Of course, the most important issue to consider is the actual
fault detection experience that we have for the two projects
that used the DST algorithm as the basis for their test case
generation during load testing. Recall that these projects have
gone through extensive functionality testing at several levels,
prior to entering the load testing phase, and are generally expected to be very stable at this stage.

One of the projects discovered one fault that was associated
with an architectural problem that only manifested itself when
the system was run according to the operational profile with a
specific number of customers. The tester responsible for this
testing stated that he believed that without the use of our generated test suite, the fault would have probably gone undetected until the problem caused a serious field failure. In addition, he felt that the fact that DST is entirely deterministic in
terms of the set of test cases generated by the algorithm, implies that when an intermittent problem occurs during load
testing, it is easy to reproduce such problems, which are notoriously difficult to identify and fix with other testing approaches. Therefore, he felt that it would have been much
more difficult to identify the exact situation that had caused the
failure without this approach, and its associated reproducible
test sets, and therefore debugging the system would also have
been significantly more difficult. 
The tester involved with running the load testing suite generated by our tool for the other production system felt that
there were several major benefits of using the algorithm that
their project realized. The first benefit was that they were
forced to more closely analyze their requirements than usual,
and to identify the information they had, and, more important,
the information they did not have, but needed. They used the
list of test cases generated by the DST tool exclusively, replacing the usual method of hand-crafting test cases. This allowed
them to produce many more test cases, and with much greater
variety than usual. They therefore found that this gave them a
much more realistic approximation of the load the system was
likely to encounter in the field. The most important benefit
they identified was that they uncovered four distinct problems,
some of which were potentially severe, and in their opinion
likely to go undetected until the software was operational in
the field. In summation, they felt that by using our approach to
load testing, they were able to test their software more thoroughly and exercise it in ways that would not have been done
without the use of the technique. In addition, the extra cost of
using this approach was minimal, since it replaced, in large
part, work that they would have done without it. 

\section{SOFTWARE EVALUATIO}

\end{document}